*** Types, data

* Game Data:

Dict
-> Dict Items
key/word ; Qty ; Output (word/letter) and/or Outcome  : effect, maybe token/wildcard... ; Long Desc, Short Desc ; maybe Visibility score
[should output and outcome be separate concepts?]

Keyboard

-> Key Info : Visibility wrt glyphs

AutoRepeat speed(s)

----------

* Game State:

Dict displayed/unlocked/activated

Keyboard State

Glyphs score (internal)

Longpress Autorepeat delay

Autorepeat status (later)

----------

UI State:

Highlight duration
Tick
Dict dimensions (row, columns)
Welcome message
Keyboard dims(maybe)

--------------------------------------------------------------------------------------------------

*** The Game

Same sequence as before with I, IN, INN, E, WIN mcguffin etc:

I word -> open 2 letter words. [ should there be something required to unlock this?]
(maybe) 50I->reveal N [N appears after 50 glyphs. typing N results in red feedback and maybe log message ("letter N not available")]
10I letter->N
IN->unlock 3 letter words
INN->key automation ( purchases I automation (mediated by a repeat function key: ctrl))
10N letter->unlock E? (or better price 1000N?)
WIN : win the game [display early on]
(maybe)[sth]->W  [display a bit later]
(maybe)[sth]->unlock N for good

Type available letters:
I, maybe N (when unlocked)



Qs:

*Base mechanics/word typing:
buy from anywhere? or only top of "input stack"? -> Can buy from anywhere, but starting from right to left.
Typing order: add to the right.
Claiming a letter is simpler : type letter (temp. activated on keyboard), get letter
"Enter" key to claim (rightmost word). Ambiguous, How do I decide what word to claim? -> Rightmost
Enter also works as word repeat key. (slow at first)
"Claim word, get effect" for now. No in-stream tokens
If I purchase a letter N, does it a) replace the 10I in-place? Or b) is it added to the end of the stream? a) most certainly
I(15)ENI(5) -> press E :a)  I(5)EENI(5) or  b) I(5)ENI(5)E !

Can I take words/letters from different places to make up the total n? ie : I(3)FOOI(7) -> FOOE? 

I can't see the words like this. best IENI with the 5's underneath? or smaller as subscript?

Do we allow word combos with n > 1 input? eg "REP(3) => W"
Would this mean REPREPREP? or RRREEEPPP? both?
-> don't have it for now

-Other
Do some DictItems disappear after use? -> no need to answer that now

-------



Impl note for the buying system
keypresses produce 1 key if key is unlocked in keyboard
or 1 purchase ("10I -> N") if key is temp. unlocked/10I available
or a word purchase if it's Enter

We need to process input stream to see 1) what actions are available 2) what their outcome is
Classifying:
Keypress -> Add 1 letter to the end of input
Purchase letter : transform 1 input element into 1 or 2 others. i(15) -> i(5)n i(10) ->n
Purchase word: remove/reduce k consecutive input elements, where k is length of word. Maybe add l elements (the new word) after

* Processing:
1) produce combo list. A list of DictItems that are applicable.
=> done in testProcessing.ts
2) (input, combos, action -> input) : the transform. 
Action is a letter keypress or Enter

* What to use for Processing

The base data structure is a sequence S of "letters(repetition number n)"
Every "frame", I Need to build up an easy-to-use list of words existing in it.

Hash table W : {word -> [location indices in S, from right to left, also noting multiplicity]},
List of words and isolated letters, in order for rendering/painting purposes

(S, dict)-> Hash Table L: "x times letter" reward available, ie note the locations of the 10I, etc
Hash table W update : {Dict Item ID -> [location indices in S, from right to left]}
And ID/location of the rightmost Dict Item. Or maybe a list of all the Dict Item IDs present, in order! There is overlap though.
Separate letter Dict Items and Word Dict Items to avoid overlap

bc What does Enter buy ? rightmost "Word" Dict Item
What does N buy? Rightmost 10I

Compute these Hash tables W, L, every frame for now
Use S = array for now

Later:
S should have easy subsequence insertion (word/letter replaced by word/letter, or word/letter added),
 mutability (decrease n by 1 within a range), 
Partially Recompute Hash tables and lists on modification of S
Keep a data structure of all the words present in S, update(not recompute) every frame

Operations on S:
-add 1 letter at the end
-remove a (multiple) letter
-remove a (multiple) word
-Add a letter at a location
-Add a word at a location
-Compute data structures above

After each frame, filter out all the n==0 letters

Should stream be linked list? It needs fast insert/delete
Test this with a wide range of keyboard keys and words available (not just INN)!





Q : separating into words. There can be ambiguity! Form the largest words? Or most multiple?
Overlapping words:
M(5)U(5)L(5)T(5)I(5) + N N 
-> MULT(5)I(4) INN? steal the last I?

first word formed?
Allow sharing? OK, but how does painting work?
I can recompute every time, only need to paint < 30 letters anyway?
Do I need to paint?
Overlapping words can be displayed by combo of colors, underlining, font, font weight, whatever

=> Done : see testsplit.ts for an implementation
no overlapping words for now.




Arguments to Input component? 3 args at least:
Letter array obvs. also delimited-word array? or list of word-starting indices?
Yes, bc Input component shouldn't have access to dictionary.
Does the current prefix/word being typed have special status? Yes. 
3rd arg : index of current Input element being typed.    
